##### 第4章 Redis

-  4-1 Redis简介

  - 为什么Redis能这么快？

    - 100000+QPS（QPS即query per second，每秒内查询次数）

    1. 完全基于内存，绝大部分请求是纯粹的内存操作，执行效率高
    2. 数据结构简单，对数据操作也简单
    3. 采用单线程，单线程也能处理高并发请求，想多核也可启动多实例
    4. 使用I/O复用模型，非阻塞IO

-  4-2 Redis常用数据类型

  - String：最基本的数据类型，二进制安全
  - Hash：String元素组成的字典，适合用于存储对象
  - List：列表，按照String元素插入顺序排序
  - Set：String元素组成的无序集合，通过哈希表实现，不允许重复
  - Sorted Set：通过分数来为集合中的成员进行从小到大的排序
  - 用于计数的HyperLogLog，用于支持存储地理位置信息的Geo

-  4-3 从海量数据里查询某一固定前缀的key 

  - 摸清数据规模，即问清楚边界
  - 使用keys对线上的业务的影响
    - keys pattern：查找所有符合给定模式pattern的key
  - scan cursor [match pattern] [count count]
    - 例子：scan 0 match k1* count 10
    - 基于游标的迭代器，需要基于上一次的游标延续之前的迭代过程
    - 以0作为游标开始一次新的迭代，直到命令返回游标0完成一次遍历
    - 不保证每次执行都返回某个给定数量的元素，支持模糊查询
    - 一次返回的数量不可控，只能是大概率符合count参数

-  4-4 如何实现分布式锁

  - 分布式锁需要解决的问题
    - 互斥性
    - 安全性
    - 死锁
    - 容错
  - 如何通过Redis实现分布式锁
    - setnx key value：如果key不存在，则创建并赋值
    - set key value [ex seconds] [px molliseconds] [nx|xx]
      - ex second：设置键的过期时间为second秒
      - px millisecond：设置键的过期时间为millisecond毫秒
      - nx：只在键不存在时，才对键进行设置操作
      - xx：只在键已经存在时，才对键进行设置操作
      - set操作成功完成时，返回ok，否则返回nil
  - 如何解决setnx长期有效的问题
    - expire key seconds
      - 设置key的生存时间，当key过期时（生存时间为0），会被自动删除
      - 缺点：原子性得不到满足
  - 大量的key同时过期的注意事项
    - 集中过期，由于清除大量的key很耗时，会出现短暂的卡顿现象
      - 解决方案：在设置key的过期时间的时候，给每个key加上随机值

-  4-5 如何实现异步队列

  - 使用List作为队列，rpush生产消息，lpop消费消息
    - 缺点：没有等待队列里有值就直接消费
    - 弥补：可以通过在应用层引入sleep机制去调用lpop重试
  - blpop key [key ...] timeout：阻塞直到队列有消息或者超时
    - 缺点：只能供一个消费者消费
  - pub/sub：主题订阅者模式
    - 发送者（pub）发送消息，订阅者（sub）接收消息
    - 订阅者可以订阅任意数量的频道
    - 缺点：消息的发布是无状态的，无法保证可达

-  4-6 持久化方式之RDB

  - RDB（快照）持久化：保存某个时间点的全量数据快照
    - save：阻塞Redis的服务器进程，直到RDB文件被创建完毕
    - bgsave：fork出一个子进程来创建RDB文件，不阻塞服务器进程
  - 自动化触发RDB持久化的方式
    - 根据redis.conf配置里的SAVE m n 定时触发（用的是BGSAVE）
    - 主从复制时，主节点自动触发
    - 执行Debug Reload
    - 执行Shutdown且没有开启AOF持久化
  - RDB持久化的缺点
    - 内存数据的全量同步，数据量大会由于I/O而严重影响性能
    - 可能会因为Redis挂掉而丢失从当前至最近一次快照期间的数据

-  4-7 持久化方式之AOF以及混合模式

  - AOF（Append-Only-File）持久化：保存写状态
    - 记录下除了查询以外的所有变更数据库状态的指令
    - 以append的形式追加保存到AOF文件中（增量）
  - 日志重写解决AOF文件大小不断增大的问题
  - RDB和AOF文件共存情况下的恢复流程
    - 存在AOF优先加载AOF，存在RDB则加载RDB
  - RDB和AOF的优缺点
    - RDB优点：全量数据快照，文件小，恢复快
    - RDB缺点：无法保存最近一次快照之后的数据
    - AOF优点：可读性高，适合保存增量数据，数据不易丢失
    - AOF缺点：文件体积大，恢复时间长
  - RDB-AOF混合持久化方式
    - bgsave做镜像全量持久化，AOF做增量持久化

-  4-8 Pipeline及主从同步

  - 使用pipeline的好处
    - pipeline和linux的管道类似
    - Redis基于请求/响应模型，单个请求处理需要一一应答
    - pipeline批量执行指令，节省多次IO往返的时间
    - 有顺序依赖的指令建议分批发送
  - Redis的同步机制
    - 主从同步原理
    - Redis Sentinel（哨兵）
      - 解决主从同步Master宕机后的主从切换问题
        - 监控：检查主从服务器是否运行正常
        - 提醒：通过API向管理员或者其他应用程序发送故障通知
        - 自动故障迁移：主从切换

-  4-9 Redis集群

  - 如何从海量数据里快速找到所需？
    - 分片：按照某种规则去划分数据，分散存储在多个节点上
    - 常规的按照哈希划分无法实现节点的动态增减
  - 一致性哈希算法：对2^32取模，将哈希值空间组织成虚拟的圆环
  - 将数据key使用相同的函数Hash计算出哈希值
  - Hash环的数据倾斜问题
  - 引入虚拟节点解决数据倾斜的问题

-  4-10 本章总结