##### 第8章 Java多线程与并发

- 8-1 进程和线程的区别

  进程是资源分配的最小单位，线程是CPU调度的最小单位

  1. 线程不能看做独立应用，而进程可看做独立应用
  2. 进程有独立的地址空间，相互不影响，线程只是进程的不同执行路径
  3. 线程没有独立的地址空间，多进程的程序比多线程程序健壮
  4. 进程的切换比线程的切换开销大

  Java进程和线程的关系

  1. Java对操作系统提供的功能进行封装，包括进程和线程
  2. 运行一个程序会产生一个进程，进程包含至少一个线程
  3. 每个进程对应一个JVM实例，多个线程共享JVM里的堆
  4. Java采用单线程编程模型，程序会自动创建主线程
  5. 主线程可以创建子线程，原则上要后于子线程完成执行

- 8-2 线程的start和run方法的区别

  - 调用start()方法会创建一个新的子线程并启动
  - run()方法只是Thread的一个普通方法的调用

- 8-3 Thread和Runnable的关系

  - Thread是实现了Runnable接口的类，使得run支持多线程
  - 因类的单一继承原则，推荐多使用Runnable接口

- 8-4 如何实现处理线程的返回值

  - 主线程等待法
  - 使用Thread类的join()阻塞当前线程以等待子线程处理完毕
  - 通过Callable接口实现：通过FutureTask Or 线程池获取 

- 8-5 线程的状态

  - 新建（New）：创建后尚未启动的线程的状态
  - 运行（Runnable）：包含Running和Ready
  - 无限期等待（Waiting）：不会被分配CPU执行时间，需要显示被唤醒
  - 限期等待（Timed Waiting）：在一定时间后会由系统自动唤醒
  - 阻塞（Blocked）：等待获取排他锁 
  - 结束（Terminated）：已终止线程的状态，线程已经结束执行

- 8-6 sleep和wait的区别

  - sleep是Thread类的方法，wait是Object类中定义的方法
  - sleep()方法可以在任何地方使用
  - wait()方法只能在synchronized方法或synchronized块中使用
  - Thread.sleep只会让出CPU，不会导致锁行为的改变
  - Object.wait不仅让出CPU，还会释放已经占有的同步资源锁

- 8-7 notify和notifyall的区别

  - notifyall会让所有处于等待池的线程全部进入锁池去竞争获取锁的机会
  - notify只会随机选取一个处于等待池中的线程进入锁池去竞争获取锁的机会

- 8-8 yield函数

  - 当调用Thread.yield()函数时，会给线程调度器一个当前线程愿意让出CPU使用的暗示，但是线程调度器可能会忽略这个暗示。

- 8-9 interrupt函数

  - 如何中断线程
    - 调用interrupt()，通知线程应该中断了

- 8-10 前述方法及线程状态总结

  - 线程状态图

- 8-11 彩蛋之如何有效谈薪

  - 尽量打听公司岗位的薪酬幅度
  - 已经具备有竞争力的offer